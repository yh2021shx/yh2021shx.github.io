{"meta":{"title":"yh2021shx's blog","subtitle":"喵喵的博客","description":"学 whk 学累了就来这里睡一会~","author":"yh2021shx","url":"https://yh2021shx.github.com","root":"/"},"pages":[{"title":" ","date":"12/11/2023","updated":"12/11/2023","comments":true,"path":"homepage.html","permalink":"https://yh2021shx.github.com/homepage.html","excerpt":"","text":""},{"title":"","date":"10/11/2023","updated":"10/11/2023","comments":true,"path":"404.html","permalink":"https://yh2021shx.github.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"404 喵","date":"14/07/2023","updated":"07/08/2023","comments":true,"path":"404/index.html","permalink":"https://yh2021shx.github.com/404/index.html","excerpt":"","text":"我的心脏还在跳动着啊。"},{"title":"OI 笔记","date":"10/11/2023","updated":"28/12/2023","comments":true,"path":"OlympicInformation/index.html","permalink":"https://yh2021shx.github.com/OlympicInformation/index.html","excerpt":"","text":"[AT_abc313_d] Odd or Even Odd or Even 简单题，但是为什么赛场上 WA 了呢？ 弱化题目，设 n=k+1n = k + 1n=k+1，发现只需要每一个数不取询问 kkk 次，通过前缀和得出。 再设 k+1 ∣ nk + 1 \\ | \\ nk+1 ∣ n，发现只需要类似分块即可解决。 回到原题，最后的一部分如何计算？我们可以对 [n−k,n][n - k, n][n−k,n] 这个区间做询问，但是对于已经计算的数不再去除。把每一个得到的和减去前面已经计算的数的和就是真实的和，类似的也能计算出。 询问次数刚好为 nnn，时间复杂度为 O(n)\\mathcal{O}(n)O(n)，可以通过此题。 1234567891011121314151617181920212223242526272829303132333435void solve() &#123; n = read(), k = read(); for (i = 1; i + k &lt;= n; i += k + 1) &#123; int sum = 0; for (int j = i; j &lt;= i + k; j ++) &#123; cout &lt;&lt; &quot;? &quot;; for (int l = i; l &lt;= i + k; l ++) if (l != j) cout &lt;&lt; l &lt;&lt; &quot; &quot;; cout &lt;&lt; endl; b[j] = read(); sum ^= b[j]; &#125; for (int j = i; j &lt;= i + k; j ++) a[j] = sum ^ b[j]; &#125; // 剩下的部分不一定长度为奇 if (n % (k + 1) != 0) &#123; int res = 0; for (int j = i - k + 1; j &lt; i; j ++) res ^= a[j]; for (int j = i; j &lt;= n; j ++) &#123; cout &lt;&lt; &quot;? &quot;; for (int l = i - k + 1; l &lt; i; l ++) cout &lt;&lt; l &lt;&lt; &quot; &quot;; cout &lt;&lt; j &lt;&lt; endl; b[j] = read(); a[j] = (b[j] ^ res); &#125; &#125; cout &lt;&lt; &quot;! &quot;; for (i = 1; i &lt;= n; i ++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; cout &lt;&lt; endl;&#125; P9493 「SFCOI-3」进行一个列的排 dp 好题。 首先手玩样例，考虑极端情况，发现 n−1n-1n−1 一定放左边或者右边。发现可以不考虑 n−1n-1n−1，则每个数只能放左边或者右边。 考虑只设一维的 dpidp_idpi​ 表示前 iii 个数的合法情况，发现显然过不了样例，比如样例 111，我们发现 222 和 333 是不能放一起的。 那么容易列出 dpi,jdp_{i,j}dpi,j​ 表示前 iii 个数中，jjj 个放左边的合法数量，转移方程易得。此题结。 12345678g (i, n, 1) &#123; f (j, 0, n - i + 1) &#123; dp[i][j] = 0; if (p[i] &lt;= n - j &amp;&amp; j &gt; 0 &amp;&amp; p[i] &gt;= i - 1) dp[i][j] = dp[i + 1][j - 1]; if (p[i] &lt;= j + i - 1 &amp;&amp; n - i - j + 1 &gt; 0 &amp;&amp; p[i] &gt;= i - 1) (dp[i][j] += dp[i + 1][j]) %= mod; if (i == 2) (ans += dp[i][j]) %= mod; &#125;&#125; UVA-5950 Recursive sequence 典中典矩阵乘法模板题。不难推出以下矩阵： [1214641100000000146410001331000012100000110000001]\\begin{bmatrix} 1 &amp; 2 &amp; 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1\\\\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 3 &amp; 3 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 2 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\\\ \\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​1100000​2000000​1010000​4041000​6063100​4043210​1011111​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int mtx[7][7] = &#123; &#123;1, 2, 1, 4, 6, 4, 1&#125;, &#123;1, 0, 0, 0, 0, 0, 0&#125;, &#123;0, 0, 1, 4, 6, 4, 1&#125;, &#123;0, 0, 0, 1, 3, 3, 1&#125;, &#123;0, 0, 0, 0, 1, 2, 1&#125;, &#123;0, 0, 0, 0, 0, 1, 1&#125;, &#123;0, 0, 0, 0, 0, 0, 1&#125;&#125;;struct matrix&#123; int a[7][7], n, m; matrix operator * (const matrix p) const &#123; matrix res; res.n = n, res.m = p.m; f (i, 0, res.n - 1) f (j, 0, res.m - 1) &#123; res.a[i][j] = 0; f (k, 0, m - 1) (res.a[i][j] += a[i][k] * p.a[k][j] % mod) %= mod; &#125; return res; &#125;&#125; P, A, B;matrix ksm(matrix p, int k) &#123; matrix res = P; for (; k; k &gt;&gt;= 1, (p = p * p)) if (k &amp; 1) res = res * p; return res;&#125;void solve() &#123; n = read(), a = read(), b = read(); f (i, 0, 6) f (j, 0, 6) P.a[i][j] = B.a[i][j] = 0, A.a[i][j] = mtx[i][j]; P.n = P.m = 7; A.n = A.m = 7; f (i, 0, 6) P.a[i][i] = 1; B.n = 7, B.m = 1; B.a[0][0] = b, B.a[1][0] = a; B.a[2][0] = 16, B.a[3][0] = 8, B.a[4][0] = 4, B.a[5][0] = 2, B.a[6][0] = 1; if (n == 1) &#123; printf(&quot;%lld\\n&quot;, a); return ; &#125; if (n == 2) &#123; printf(&quot;%lld\\n&quot;, b); return ; &#125; matrix ans = ksm(A, n - 2) * B; printf(&quot;%lld\\n&quot;, ans.a[0][0]);&#125; P3225 [HNOI2012] 矿场搭建 水题，简单建一棵圆方树，然后对于每一个点双开始分类讨论。 割点只有一个，那么需要染一个除割点外的一点。 没有割点，随便选两个点。 其他情况，发现前面两种情况搞定这个点双直接高枕无忧了，不操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void Tarjan(int u, int rt) &#123; st.push(u); int x = 0; dfn[u] = low[u] = ++ tim; for (int v : to[u]) &#123; if (!dfn[v]) &#123; x ++; Tarjan(v, rt); low[u] = min(low[u], low[v]); if (dfn[u] &lt;= low[v]) &#123; if (u != rt) cut[u] = 1; col[u].push_back(++ dcc); siz[dcc] = 1; col[v].push_back(dcc); siz[dcc] ++; while (st.top() != v) &#123; col[st.top()].push_back(dcc); siz[dcc] ++; st.pop(); &#125; st.pop(); &#125; &#125; else low[u] = min(low[u], dfn[v]); &#125; if (u == rt &amp;&amp; x &gt;= 2) &#123; cut[u] = 1; &#125;&#125;void solve(int id) &#123; tim = dcc = 0; for (int i = 1; i &lt;= n; i ++) &#123; vis[i] = false; cut[i] = false; num[i] = siz[i] = dfn[i] = low[i] = 0; to[i].clear(); col[i].clear(); &#125; while (!st.empty()) st.pop(); for (int i = 1, u, v; i &lt;= m; i ++) &#123; scanf(&quot;%d %d&quot;, &amp;u, &amp;v); to[u].push_back(v); to[v].push_back(u); vis[u] = vis[v] = true; &#125; for (int i = 1; i &lt;= n; i ++) if (!dfn[i] &amp;&amp; vis[i]) Tarjan(i, i); for (int i = 1; i &lt;= n; i ++) if (vis[i] &amp;&amp; cut[i]) for (int x : col[i]) num[x] ++; int ans1 = 0; long long ans2 = 1; for (int i = 1; i &lt;= dcc; i ++) &#123; if (num[i] == 1) &#123; ans1 ++; ans2 *= (siz[i] - 1); &#125; else if (num[i] == 0) &#123; ans1 += 2; ans2 *= 1ll * siz[i] * (siz[i] - 1) / 2; &#125; &#125; printf(&quot;Case %d: %d %lld\\n&quot;, id, ans1, ans2);&#125; CF1458E Nim Shortcuts 其实发现性质之后就很简单了。 不会题，就考虑 n=0n = 0n=0。当 n=0n = 0n=0 时，发现是 Nim 游戏的二维形式，抽象成直角坐标系就是对角线。 考虑依次加入结点，不难发现每次加入结点之后会出现行被删除，对角线上移一格的情况。同理，加入结点之后会出现列被删除，对角线右移一格的情况。发现之后直接二位数点，然后细节跟 shi 一样多。然后就做完了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465struct Node &#123; int a, b, id; bool operator &lt; (const Node &amp;x) const &#123; return a &lt; x.a || (a == x.a &amp;&amp; (b &lt; x.b || (b == x.b &amp;&amp; id &lt; x.id))); &#125; &#125; p[N * 2];namespace BIT &#123; int tr[N], nn; int lowbit(int x) &#123; return x &amp; (-x);&#125; void init(int p) &#123; nn = p; for (int i = 1; i &lt;= nn; i ++) tr[i] = 0;&#125; void update(int x, int y) &#123; for (; x &lt;= nn; x += lowbit(x)) tr[x] += y;&#125; int query(int x) &#123; int res = 0; for (; x; x -= lowbit(x)) res += tr[x]; return res;&#125;&#125; using namespace BIT;signed main() &#123; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) &#123; scanf(&quot;%d %d&quot;, &amp;p[i].a, &amp;p[i].b); p[i].id = 0; tmp[i] = p[i].b; &#125; sort(tmp + 1, tmp + n + 1); int k = unique(tmp + 1, tmp + n + 1) - tmp - 1; set &lt;pair &lt;int, int&gt; &gt; x; init(k); for (int i = 1; i &lt;= m; i ++) &#123; scanf(&quot;%d %d&quot;, &amp;p[i + n].a, &amp;p[i + n].b); p[i + n].id = i; &#125; sort(p + 1, p + n + m + 1); for (int i = 1; i &lt;= n + m; i ++) &#123; if (p[i].id &gt; 0) &#123; if (x.find(&#123;p[i].a, p[i].b&#125;) != x.end()) &#123; ans[p[i].id] = 1; &#125; else &#123; int pos = upper_bound(tmp + 1, tmp + k + 1, p[i].b) - tmp - 1; int y = query(pos); if (p[i].a == cut || vis[pos] &amp;&amp; tmp[pos] == p[i].b) &#123; ans[p[i].id] = 0; &#125; else &#123; ans[p[i].id] = (p[i].a - siz == p[i].b - y); &#125; &#125; &#125; else &#123; int pos = lower_bound(tmp + 1, tmp + k + 1, p[i].b) - tmp; int cur = siz - query(pos); if (p[i].a - p[i].b &lt; cur) &#123; if (!vis[pos]) &#123; vis[pos] = 1; update(pos, 1); &#125; &#125; else if (p[i].a - p[i].b &gt; cur) &#123; if (p[i].a != cut) &#123; cut = p[i].a; siz ++; &#125; &#125; x.insert(&#123;p[i].a, p[i].b&#125;); &#125; &#125; for (int i = 1; i &lt;= m; i ++) printf(ans[i] == 1 ? &quot;LOSE\\n&quot; : &quot;WIN\\n&quot;); return 0;&#125; CF1033G Chip Game 显然 A 和 B 是等价的，故容斥考虑先手和后手。 发现若两个局面在模 a+ba + ba+b 意义下是同余的，则两种局面等价。证明显而易见，后手可以跟着先手取。 啊哈哈十分不显然，滚去 LG 题解吧！ 于是考虑简化意义下的。把取不了的堆先给去掉。 然后考虑跟先后手无关的情况（假设 a&lt;ba &lt; ba&lt;b）： 有一个 a≤p&lt;ba \\leq p &lt; ba≤p&lt;b。a 先随便取，但是不能取满足要求的这一堆。如果 a 取不了了，就取这一堆。 有一个 2×a≤p2 \\times a \\leq p2×a≤p。很 shaber，非常显然。你分讨一下两种情况，考虑 A 是先手还是后手。如果 A 是先手，则可以转换成上一种情况。否则，B 可以阻止 A，然后 B 就赢了。反正结论就是先手必胜。 有不止一个 2×a≤p2 \\times a \\leq p2×a≤p，那一定能转换成第一种情况。A 必赢。 于是发现第二种情况和 b≤p&lt;2×ab \\leq p &lt; 2 \\times ab≤p&lt;2×a。 写不动了。 （to be continued）"},{"title":"关于我","date":"13/03/2021","updated":"25/10/2023","comments":true,"path":"about/index.html","permalink":"https://yh2021shx.github.com/about/index.html","excerpt":"","text":"你好！ 我叫 yh2021shx，是可爱小喵一枚呀~ 很菜很菜，认识我的人不要把我爆踩就行！"},{"title":"所有分类","date":"28/10/2023","updated":"28/10/2023","comments":true,"path":"categories/index.html","permalink":"https://yh2021shx.github.com/categories/index.html","excerpt":"","text":"喵呜~"},{"title":"小目标","date":"11/11/2023","updated":"11/11/2023","comments":true,"path":"Target/index.html","permalink":"https://yh2021shx.github.com/Target/index.html","excerpt":"","text":""},{"title":"友链","date":"14/07/2023","updated":"29/10/2023","comments":true,"path":"friends/index.html","permalink":"https://yh2021shx.github.com/friends/index.html","excerpt":"","text":"如有遗漏记得告诉我。"},{"title":"所有标签","date":"28/10/2023","updated":"28/10/2023","comments":true,"path":"tags/index.html","permalink":"https://yh2021shx.github.com/tags/index.html","excerpt":"","text":""},{"title":"黑暗模式切换","date":"26/10/2023","updated":"26/10/2023","comments":true,"path":"darkchange/index.html","permalink":"https://yh2021shx.github.com/darkchange/index.html","excerpt":"","text":"主题切换"},{"title":"countdown","date":"01/01/2000","updated":"19/11/2023","comments":true,"path":"sidebar/countdown.html","permalink":"https://yh2021shx.github.com/sidebar/countdown.html","excerpt":"","text":"天 : :"},{"title":"notification","date":"01/01/2000","updated":"12/11/2023","comments":true,"path":"sidebar/notification.html","permalink":"https://yh2021shx.github.com/sidebar/notification.html","excerpt":"","text":"本站默认替换了右键菜单，唤醒原系统菜单： ctrl + 右键。"},{"title":"talk","date":"01/01/2000","updated":"19/11/2023","comments":true,"path":"sidebar/talk.html","permalink":"https://yh2021shx.github.com/sidebar/talk.html","excerpt":"","text":"真的是最后一年打 OI 了。"},{"title":"Welcome","date":"04/11/2023","updated":"04/11/2023","comments":true,"path":"welcome/index.html","permalink":"https://yh2021shx.github.com/welcome/index.html","excerpt":"","text":""}],"posts":[{"title":"【2024-2-16】 历经弦音","slug":"【2024-2-16】 历经弦音","date":"16/02/2024","updated":"16/02/2024","comments":true,"path":"2024/02/16/【2024-2-16】 历经弦音/","link":"","permalink":"https://yh2021shx.github.com/2024/02/16/%E3%80%902024-2-16%E3%80%91%20%E5%8E%86%E7%BB%8F%E5%BC%A6%E9%9F%B3/","excerpt":"","text":"我们先考虑一个分块的做法。 把整个图按照列分块，每块大小为 BBB，总共 ⌈mB⌉\\left \\lceil \\frac{m}{B} \\right \\rceil⌈Bm​⌉。每一块内我们直接维护出从左边跳到右边的下标数组，这样可以做到查询 O(q×n×B)\\mathcal{O}(q \\times n \\times B)O(q×n×B) 修改 O(q×n×⌈mB⌉)\\mathcal{O}(q \\times n \\times \\left \\lceil \\frac{m}{B} \\right \\rceil)O(q×n×⌈Bm​⌉)。但这样是不优的。 考虑使用线段树。我们让线段树上的每一段区间维护从 lll 跳到 rrr 的一个下标数组，记它为 nxtinxt_{i}nxti​。那么假设要把 [l,p][l, p][l,p] 和 [p+1,r][p + 1, r][p+1,r] 合并，只需要 pnxti=nxtrnxtlipnxt_i = nxtr_{nxtl_{i}}pnxti​=nxtrnxtli​​。这样可以快速维护从第一列走 mmm 步回到第一列的下标数组。然后可以找循环节，然后复杂度 O(q×m×log⁡m)\\mathcal{O}(q \\times m \\times \\log{m})O(q×m×logm)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5007;int n, m, q;int a[N][N];int x, y, z;int vis[N];int siz, pre;int cyc[N], cnt;struct Tree &#123; int nxt[N];&#125; tr[N &lt;&lt; 2];void pushUp(int x) &#123; for (int i = 0; i &lt; n; i ++) tr[x].nxt[i] = tr[x * 2 + 1].nxt[tr[x * 2].nxt[i]];&#125;int pren(int x) &#123; return (x + 1) % n;&#125;int sufn(int x) &#123; return (x + n - 1) % n;&#125;int prem(int x) &#123; return (x + 1) % m;&#125;int sufm(int x) &#123; return (x + m - 1) % m;&#125;int go(int p, int q) &#123; q = prem(q); int num = max(&#123;a[pren(p)][q], a[p][q], a[sufn(p)][q]&#125;); if (num == a[pren(p)][q]) return pren(p); else if (num == a[p][q]) return p; else return sufn(p);&#125;int read() &#123; char c = getchar(); int x = 0, p = 1; while ((c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;) c = getchar(); if (c == &#x27;-&#x27;) p = -1, c = getchar(); while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48), c = getchar(); return x * p;&#125;void Build(int x, int l, int r) &#123; if (l == r) &#123; for (int i = 0; i &lt; n; i ++) tr[x].nxt[i] = go(i, l); return ; &#125; int mid = l + r &gt;&gt; 1; Build(x * 2, l, mid); Build(x * 2 + 1, mid + 1, r); pushUp(x);&#125;void update(int x, int l, int r, int p, int q) &#123; if (l == r) &#123; for (int i = 0; i &lt; n; i ++) tr[x].nxt[i] = go(i, l); return ; &#125; int mid = l + r &gt;&gt; 1; if (q &lt;= mid) update(x * 2, l, mid, p, q); else update(x * 2 + 1, mid + 1, r, p, q); pushUp(x);&#125;void getCyc(int x, int y) &#123; fill(vis, vis + n + 1, 0); cnt = 0, cyc[0] = x, x = tr[1].nxt[x]; while (!vis[x]) &#123; vis[x] = ++ cnt; cyc[cnt] = x; x = tr[1].nxt[x]; &#125; siz = cnt - vis[x] + 1, pre = vis[x] - 1;&#125;void move(int &amp;x, int &amp;y, int k) &#123; int walk = 0; while (k &amp;&amp; y) &#123; x = go(x, y); y = prem(y); k --; walk ++; &#125; if (!k) return ; int k1 = k / m; k %= m; getCyc(x, y); if (k1 &lt;= pre) x = cyc[k1]; else x = cyc[(k1 + siz - pre - 1) % siz + pre + 1]; walk = 0; while (k) &#123; x = go(x, y); y = prem(y); k --; walk ++; &#125;&#125;signed main() &#123; n = read(), m = read(); for (int i = 0; i &lt; n; i ++) for (int j = 0; j &lt; m; j ++) a[i][j] = read(); Build(1, 0, m - 1); q = read(); int px = 0, py = 0; while (q --) &#123; string s; cin &gt;&gt; s; x = read(); if (s == &quot;move&quot;) &#123; move(px, py, x); cout &lt;&lt; px + 1 &lt;&lt; &#x27; &#x27; &lt;&lt; py + 1 &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; y = read(), z = read(); x --, y --; a[x][y] = z; update(1, 0, m - 1, x, sufm(y)); &#125; &#125; return 0;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://yh2021shx.github.com/categories/Solutions/"},{"name":"School","slug":"Solutions/School","permalink":"https://yh2021shx.github.com/categories/Solutions/School/"}],"tags":[{"name":"School","slug":"School","permalink":"https://yh2021shx.github.com/tags/School/"},{"name":"线段树","slug":"线段树","permalink":"https://yh2021shx.github.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"图论","slug":"图论","permalink":"https://yh2021shx.github.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"循环节","slug":"循环节","permalink":"https://yh2021shx.github.com/tags/%E5%BE%AA%E7%8E%AF%E8%8A%82/"}]},{"title":"CF1922E Increasing Subsequences","slug":"CF1922E Increasing Subsequences","date":"16/02/2024","updated":"16/02/2024","comments":true,"path":"2024/02/16/CF1922E Increasing Subsequences/","link":"","permalink":"https://yh2021shx.github.com/2024/02/16/CF1922E%20Increasing%20Subsequences/","excerpt":"","text":"一个显然的思路就是构造很多互不相关的上升序列。但是这样构造出来的 nnn 是 O(log⁡22n)O(\\log_2^2 n)O(log22​n) 量级的，所以需要考虑新做法。 假设我们本来有一个上升序列，我们能否往里面插数？如果插入的数前面本来有 xxx 个数，那么它有 2x2^x2x 的贡献。于是容易想到先写一个最大的上升序列，再二进制拆分即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;long long read() &#123; char c = getchar(); long long x = 0, p = 1; while ((c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &amp;&amp; c != &#x27;-&#x27;) c = getchar(); if (c == &#x27;-&#x27;) p = -1, c = getchar(); while (c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48), c = getchar(); return x * p;&#125;const int N = 207;long long x;void solve() &#123; x = read(); long long p = 1, k = 0; while (p * 2 &lt;= x) &#123; p *= 2; k ++; &#125; x -= p; vector &lt;int&gt; bit; int cnt = 0; while (x) &#123; bit.push_back(x % 2); cnt += (x % 2 == 1); x /= 2; &#125; cout &lt;&lt; cnt + k &lt;&lt; &#x27;\\n&#x27;; for (int i = 0, j = cnt + k; i &lt;= k; i ++) &#123; if (i &gt; 0) cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; if (i &lt; (int) bit.size() &amp;&amp; bit[i]) cout &lt;&lt; (j --) &lt;&lt; &#x27; &#x27;; &#125; cout &lt;&lt; &#x27;\\n&#x27;;&#125;signed main() &#123; int t = 1; t = read(); while (t --) solve(); return 0;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://yh2021shx.github.com/categories/Solutions/"},{"name":"Codeforces","slug":"Solutions/Codeforces","permalink":"https://yh2021shx.github.com/categories/Solutions/Codeforces/"}],"tags":[{"name":"Div-2","slug":"Div-2","permalink":"https://yh2021shx.github.com/tags/Div-2/"},{"name":"构造","slug":"构造","permalink":"https://yh2021shx.github.com/tags/%E6%9E%84%E9%80%A0/"},{"name":"二进制","slug":"二进制","permalink":"https://yh2021shx.github.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"【XR-2】 伤痕","slug":"P5441 伤痕","date":"28/12/2023","updated":"28/12/2023","comments":true,"path":"2023/12/28/P5441 伤痕/","link":"","permalink":"https://yh2021shx.github.com/2023/12/28/P5441%20%E4%BC%A4%E7%97%95/","excerpt":"","text":"跳转到 【XR-2】 伤痕 1 关于题目 1.1 题目描述 X 国经历了一场前所未有的大地震，人们伤痕累累，整个国家破碎不堪。 为了帮助人们痊愈，也为了让 X 国能够生存下去，X 国国王决定重建 X 国。 国王决定先建造 nnn 座城市，由于国王喜欢奇数，所以 nnn 为奇数。 城市建造完后，需要给每两座城市之间都修建一条道路，即一共需要修建 n(n−1)2\\frac{n(n-1)}{2}2n(n−1)​ 条道路。 不过，修建双向道路的成本太高了，建造完 nnn 座城市后剩下的经费最多只够修建 nnn 条双向道路，而其余的道路只能修建成单向的。好在方向并不会影响修建单向道路所需的费用，因此所有单向道路的方向可以任意决定。 另外，等到重建完成后，国王决定将 444 座城市钦定为 X 国的核心城市。为促进 X 国的发展，这 444 座核心城市中的任意两座城市，必须能够在不经过非核心城市的情况下相互到达。 国王希望，你能够给他一种道路修建方案，使重建完成后选择 444 座核心城市的方案数最大化。 1.2 数据范围 1≤n≤991 \\leq n \\leq 991≤n≤99，且 n=2×k+1n = 2 \\times k + 1n=2×k+1 2 解题分析 2.1 Part 1 正难则反，考虑有哪些 444 个点是弱联通的。 从一个点向另外三个点连有向边。 从三个点向另外一个点连有向边。 A,BA, BA,B 无向边，C,DC, DC,D 无向边，A,BA, BA,B 向 C,DC, DC,D 各连一条有向边。 假设第一种有 XXX 个。 2.2 Part 2 设每个点去除无向边的出度为 SiS_iSi​，则有： ∑i=1nSi=n×(n−1)2−n=n×(n−3)2\\sum_{i = 1}^nS_i = \\frac{n \\times (n - 1)}{2} - n = \\frac{n \\times (n - 3)}{2} i=1∑n​Si​=2n×(n−1)​−n=2n×(n−3)​ 由于 (x3)\\binom{x}{3}(3x​) 是凸函数 (x≥3)(x \\geq 3)(x≥3)，则： ∑i=1n(Si3)≥n×(n−323)\\sum_{i = 1}^n\\binom{S_i}{3} \\geq n \\times \\binom{\\frac{n - 3}{2}}{3} i=1∑n​(3Si​​)≥n×(32n−3​​) 于是尝试构造 X=n×(n−323)X = n \\times \\binom{\\frac{n - 3}{2}}{3}X=n×(32n−3​​) ，其他为 000 的方案：","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://yh2021shx.github.com/categories/Solutions/"},{"name":"Luogu","slug":"Solutions/Luogu","permalink":"https://yh2021shx.github.com/categories/Solutions/Luogu/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://yh2021shx.github.com/tags/%E6%9E%84%E9%80%A0/"},{"name":"Luogu","slug":"Luogu","permalink":"https://yh2021shx.github.com/tags/Luogu/"}]},{"title":"2023 CSP-S 游记","slug":"2023CSPS","date":"10/11/2023","updated":"10/11/2023","comments":true,"path":"2023/11/10/2023CSPS/","link":"","permalink":"https://yh2021shx.github.com/2023/11/10/2023CSPS/","excerpt":"","text":"初赛 Day -? 摆烂。 Phigros，启动！ Day -3 意识到初赛快来了。 抽象。 Day -2 2021 CSP-S 做不了一点，不做了 Day -1 啊？ Day 0 J 组，做不了一点。 S 组，做不了一点。 竟然都 85 以上，那应该稳了。 Phigros，启动！ Day 1 小图灵估分出来了。 J 组：95 分 S 组：86.5 分 这是好的。 Day 114514 鸽太久了。J 挂了 5 分，这是坏的。 复赛 J 组 看题。 不会 T1。 哦我是傻逼。 不会 T2。 哦我是傻逼。 不会 T4。 哦我是傻逼。 写不出来 T3。 哦大样例过了。 我是不是阿克了。好感动。 睡觉。 S 组 看题。 一眼 T1。怎么比普及组 T1 还简单阿？？？ 开 T2。哦耶字符串。去死吧。 于是 -3h。 开 T3。哦耶大模拟，65 分跑路。 开 T4。不想写。润了。 我是不是比去年低了。感动。 后记 1oo^85|o,o 哦我 S 组 T3 怎么 o 了。我是不是不应该收鸽的。 12// if (op == 1 || op == 2)// output();","categories":[{"name":"CSP-S","slug":"CSP-S","permalink":"https://yh2021shx.github.com/categories/CSP-S/"}],"tags":[{"name":"CSP-S","slug":"CSP-S","permalink":"https://yh2021shx.github.com/tags/CSP-S/"},{"name":"游记","slug":"游记","permalink":"https://yh2021shx.github.com/tags/%E6%B8%B8%E8%AE%B0/"}]},{"title":"CSP-S 2023 题解","slug":"CSP-S2023Sol","date":"29/10/2023","updated":"10/11/2023","comments":true,"path":"2023/10/29/CSP-S2023Sol/","link":"","permalink":"https://yh2021shx.github.com/2023/10/29/CSP-S2023Sol/","excerpt":"","text":"我是马后炮，今年全是傻逼题。哈哈哈哈哈哈哈哈哈哈哈哈 A. Lock\\text{A. Lock}A. Lock 简单题，直接暴力模拟。 B. Game\\text{B. Game}B. Game 发现一定是匹配最近的相等元素，考虑栈模拟，然后如果两个时刻站内元素相等就是一个可能的解，直接哈希。 当然由于是字符串，可以直接 dpndp_ndpn​，再维护一个 pn,26p_{n, 26}pn,26​ 也可以过。但是有一个傻逼开了 dpn,26dp_{n, 26}dpn,26​ 被卡空间以为只能 85 pts\\text{85 pts}85 pts，我不说是谁 /cf /cf /cf C. Struct\\text{C. Struct}C. Struct 呵。 D. Tree\\text{D. Tree}D. Tree 容易发现答案有单调性，二分以下，然后随便乱贪，比如 dpu=min⁡(gu,dpv+1)dp_u = \\min(g_u, dp_v + 1)dpu​=min(gu​,dpv​+1)，然后做完了。/cf /cf /cf All\\text{All}All 没点实力别这么狂，跟个【小粉兔】一样傻搞 B 不如看看后面的题。","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://yh2021shx.github.com/categories/Solutions/"},{"name":"CSP-S","slug":"Solutions/CSP-S","permalink":"https://yh2021shx.github.com/categories/Solutions/CSP-S/"}],"tags":[{"name":"CSP-S","slug":"CSP-S","permalink":"https://yh2021shx.github.com/tags/CSP-S/"},{"name":"2023","slug":"2023","permalink":"https://yh2021shx.github.com/tags/2023/"}]},{"title":"ABC326 F 题题解","slug":"ABC326F","date":"28/10/2023","updated":"10/11/2023","comments":true,"path":"2023/10/28/ABC326F/","link":"","permalink":"https://yh2021shx.github.com/2023/10/28/ABC326F/","excerpt":"","text":"主要是讲折半搜索。 傻逼模板场。 首先发现奇数位影响了 y 坐标，偶数位影响了 x 坐标。则直接变成背包板子题！ 但是会超时！怎么办。考虑前半部分和后半部分先暴力处理出所有情况的和。然后二分合并。然后时间复杂度就是 O(2n4×n4)\\mathcal{O}(2^\\frac{n}{4}\\times \\frac{n}{4})O(24n​×4n​)！太震撼了哈哈哈哈哈哈哈哈哈哈哈哈！ 发现 nnn 他妈的 ≤80\\leq 80≤80，哈哈哈 220×202^{20}\\times 20220×20 做完力！！！ 然后代码，非常的好写！！！111 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455string get(int n, int tar) &#123; int len = n / 2; for (int i = 0; i &lt; (1 &lt;&lt; len); i ++) &#123; numa[i] = 0; for (int j = 1; j &lt;= len; j ++) numa[i] += (((i &gt;&gt; (j - 1)) &amp; 1) ? 1 : -1) * b[j]; &#125; for (int i = 0; i &lt; (1 &lt;&lt; (n - len)); i ++) &#123; numb[i] = &#123;0, i&#125;; for (int j = 1; j &lt;= n - len; j ++) numb[i].first += (((i &gt;&gt; (j - 1)) &amp; 1) ? 1 : -1) * b[j + len]; &#125; sort(numb, numb + (1 &lt;&lt; (n - len))); for (int i = 0; i &lt; (1 &lt;&lt; len); i ++) &#123; int pos = lower_bound(numb, numb + (1 &lt;&lt; (n - len)), (pair &lt;int, int&gt;) &#123;tar - numa[i], 0&#125;) - numb; if (numb[pos].first + numa[i] == tar) &#123; string res = &quot;&quot;; for (int j = 1; j &lt;= len; j ++) res += (((i &gt;&gt; (j - 1)) &amp; 1) ? &#x27;R&#x27; : &#x27;L&#x27;); for (int j = 1; j &lt;= n - len; j ++) res += (((numb[pos].second &gt;&gt; (j - 1)) &amp; 1) ? &#x27;R&#x27; : &#x27;L&#x27;); return res; &#125; &#125; printf(&quot;No\\n&quot;); exit(0);&#125;void solve() &#123; n = read(), x = read(), y = read(); for (int i = 1; i &lt;= n; i ++) a[i] = read(); string p, q; for (int i = 1; i &lt;= n; i += 2) &#123; b[(i + 1) / 2] = a[i]; &#125; p = get((n + 1) / 2, y); for (int i = 2; i &lt;= n; i += 2) &#123; b[i / 2] = a[i]; &#125; q = get(n / 2, x); string x = &quot; &quot;; for (int i = 1; i &lt;= n; i ++) &#123; if (i &amp; 1) x += p[(i + 1) / 2 - 1]; else x += q[i / 2 - 1]; &#125; printf(&quot;Yes\\n&quot;); int d = 1; for (int i = 1; i &lt;= n; i ++) &#123; if ((d == 1 &amp;&amp; (i &amp; 1)) || (d == -1 &amp;&amp; (i % 2 == 0))) &#123; putchar(x[i] == &#x27;L&#x27; ? &#x27;R&#x27; : &#x27;L&#x27;); &#125; else &#123; putchar(x[i]); &#125; d = (x[i] == &#x27;R&#x27; ? 1 : -1); &#125;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://yh2021shx.github.com/categories/Solutions/"},{"name":"Atcoder","slug":"Solutions/Atcoder","permalink":"https://yh2021shx.github.com/categories/Solutions/Atcoder/"}],"tags":[{"name":"ABC","slug":"ABC","permalink":"https://yh2021shx.github.com/tags/ABC/"},{"name":"折半搜索","slug":"折半搜索","permalink":"https://yh2021shx.github.com/tags/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/"}]},{"title":"做题笔记","slug":"做题笔记","date":"11/08/2023","updated":"10/11/2023","comments":true,"path":"2023/08/11/做题笔记/","link":"","permalink":"https://yh2021shx.github.com/2023/08/11/%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"[AT_abc313_d] Odd or Even 简单题，但是为什么赛场上 WA 了呢？ 弱化题目，设 n=k+1n = k + 1n=k+1，发现只需要每一个数不取询问 kkk 次，通过前缀和得出。 再设 k+1 ∣ nk + 1 \\ | \\ nk+1 ∣ n，发现只需要类似分块即可解决。 回到原题，最后的一部分如何计算？我们可以对 [n−k,n][n - k, n][n−k,n] 这个区间做询问，但是对于已经计算的数不再去除。把每一个得到的和减去前面已经计算的数的和就是真实的和，类似的也能计算出。 询问次数刚好为 nnn，时间复杂度为 O(n)\\mathcal{O}(n)O(n)，可以通过此题。 P9493 「SFCOI-3」进行一个列的排 dp 好题。 首先手玩样例，考虑极端情况，发现 n−1n-1n−1 一定放左边或者右边。发现可以不考虑 n−1n-1n−1，则每个数只能放左边或者右边。 考虑只设一维的 dpidp_idpi​ 表示前 iii 个数的合法情况，发现显然过不了样例，比如样例 111，我们发现 222 和 333 是不能放一起的。 那么容易列出 dpi,jdp_{i,j}dpi,j​ 表示前 iii 个数中，jjj 个放左边的合法数量，转移方程易得。此题结。 核心代码： 12345678g (i, n, 1) &#123; f (j, 0, n - i + 1) &#123; dp[i][j] = 0; if (p[i] &lt;= n - j &amp;&amp; j &gt; 0 &amp;&amp; p[i] &gt;= i - 1) dp[i][j] = dp[i + 1][j - 1]; if (p[i] &lt;= j + i - 1 &amp;&amp; n - i - j + 1 &gt; 0 &amp;&amp; p[i] &gt;= i - 1) (dp[i][j] += dp[i + 1][j]) %= mod; if (i == 2) (ans += dp[i][j]) %= mod; &#125;&#125; UVA-5950 Recursive sequence 典中典矩阵乘法模板题。不难推出以下矩阵： [1214641100000000146410001331000012100000110000001] \\begin{bmatrix} 1 &amp; 2 &amp; 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1\\\\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\ 0 &amp; 0 &amp; 1 &amp; 4 &amp; 6 &amp; 4 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 3 &amp; 3 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 2 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1\\\\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1\\\\ \\end{bmatrix} ⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​1100000​2000000​1010000​4041000​6063100​4043210​1011111​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​ 此题结，代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455int mtx[7][7] = &#123; &#123;1, 2, 1, 4, 6, 4, 1&#125;, &#123;1, 0, 0, 0, 0, 0, 0&#125;, &#123;0, 0, 1, 4, 6, 4, 1&#125;, &#123;0, 0, 0, 1, 3, 3, 1&#125;, &#123;0, 0, 0, 0, 1, 2, 1&#125;, &#123;0, 0, 0, 0, 0, 1, 1&#125;, &#123;0, 0, 0, 0, 0, 0, 1&#125;&#125;;struct matrix&#123; int a[7][7], n, m; matrix operator * (const matrix p) const &#123; matrix res; res.n = n, res.m = p.m; f (i, 0, res.n - 1) f (j, 0, res.m - 1) &#123; res.a[i][j] = 0; f (k, 0, m - 1) (res.a[i][j] += a[i][k] * p.a[k][j] % mod) %= mod; &#125; return res; &#125;&#125; P, A, B;matrix ksm(matrix p, int k) &#123; matrix res = P; for (; k; k &gt;&gt;= 1, (p = p * p)) if (k &amp; 1) res = res * p; return res;&#125;void solve() &#123; n = read(), a = read(), b = read(); f (i, 0, 6) f (j, 0, 6) P.a[i][j] = B.a[i][j] = 0, A.a[i][j] = mtx[i][j]; P.n = P.m = 7; A.n = A.m = 7; f (i, 0, 6) P.a[i][i] = 1; B.n = 7, B.m = 1; B.a[0][0] = b, B.a[1][0] = a; B.a[2][0] = 16, B.a[3][0] = 8, B.a[4][0] = 4, B.a[5][0] = 2, B.a[6][0] = 1; if (n == 1) &#123; printf(&quot;%lld\\n&quot;, a); return ; &#125; if (n == 2) &#123; printf(&quot;%lld\\n&quot;, b); return ; &#125; matrix ans = ksm(A, n - 2) * B; printf(&quot;%lld\\n&quot;, ans.a[0][0]);&#125;","categories":[{"name":"Notebook","slug":"Notebook","permalink":"https://yh2021shx.github.com/categories/Notebook/"}],"tags":[{"name":"Note","slug":"Note","permalink":"https://yh2021shx.github.com/tags/Note/"}]},{"title":"失去信心：二十三","slug":"二十三","date":"08/08/2023","updated":"25/10/2023","comments":true,"path":"2023/08/08/二十三/","link":"","permalink":"https://yh2021shx.github.com/2023/08/08/%E4%BA%8C%E5%8D%81%E4%B8%89/","excerpt":"","text":"twentythree\\text{twentythree}twentythree 使最后所有数相等，不难想到差分，那么操作就变成： {(0,1)→(1,0)(1,1)→(2,0)(2,1)→(0,0)\\begin{cases} (0, 1) \\rightarrow (1, 0)\\\\ (1, 1) \\rightarrow (2, 0)\\\\ (2, 1) \\rightarrow (0, 0)\\\\ \\end{cases} ⎩⎪⎪⎨⎪⎪⎧​(0,1)→(1,0)(1,1)→(2,0)(2,1)→(0,0)​ 在环上进行差分，最终差分数组全为 000，显然只能第三种操作才可行。观察发现第一种操作可以把 111 在 000 中随意移动。那么不妨将 111 不断往左边移动，遇到 111 便可以直接变成 (2,0)(2,0)(2,0)，遇到 222 就可以全部变成 000。可以用栈处理。","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://yh2021shx.github.com/categories/Solutions/"}],"tags":[{"name":"CSP-S","slug":"CSP-S","permalink":"https://yh2021shx.github.com/tags/CSP-S/"}]},{"title":"AT_abc313_d Odd or Even","slug":"[AT_abc313_d]OddorEven","date":"08/08/2023","updated":"25/10/2023","comments":true,"path":"2023/08/08/[AT_abc313_d]OddorEven/","link":"","permalink":"https://yh2021shx.github.com/2023/08/08/[AT_abc313_d]OddorEven/","excerpt":"简单题，但是为什么赛场上 WA 了呢？","text":"简单题，但是为什么赛场上 WA 了呢？ 弱化题目，设 n=k+1n = k + 1n=k+1，发现只需要每一个数不取询问 kkk 次，通过前缀和得出。 再设 k+1 ∣ nk + 1 \\ | \\ nk+1 ∣ n，发现只需要类似分块即可解决。 回到原题，最后的一部分如何计算？我们可以对 [n−k,n][n - k, n][n−k,n] 这个区间做询问，但是对于已经计算的数不再去除。把每一个得到的和减去前面已经计算的数的和就是真实的和，类似的也能计算出。 询问次数刚好为 nnn，时间复杂度为 O(n)\\mathcal{O}(n)O(n)，可以通过此题。","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://yh2021shx.github.com/categories/Solutions/"}],"tags":[{"name":"ABC","slug":"ABC","permalink":"https://yh2021shx.github.com/tags/ABC/"}]},{"title":"P9493 「SFCOI-3」进行一个列的排","slug":"P9493 「SFCOI-3」进行一个列的排","date":"08/08/2023","updated":"25/10/2023","comments":true,"path":"2023/08/08/P9493 「SFCOI-3」进行一个列的排/","link":"","permalink":"https://yh2021shx.github.com/2023/08/08/P9493%20%E3%80%8CSFCOI-3%E3%80%8D%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%B8%AA%E5%88%97%E7%9A%84%E6%8E%92/","excerpt":"","text":"首先手玩样例，考虑极端情况，发现 n−1n-1n−1 一定放左边或者右边。发现可以不考虑 n−1n-1n−1，则每个数只能放左边或者右边。 考虑只设一维的 dpidp_idpi​ 表示前 iii 个数的合法情况，发现显然过不了样例，比如样例 111，我们发现 222 和 333 是不能放一起的。 那么容易列出 dpi,jdp_{i,j}dpi,j​ 表示前 iii 个数中，jjj 个放左边的合法数量，转移方程易得。此题结。 核心代码： 12345678g (i, n, 1) &#123; f (j, 0, n - i + 1) &#123; dp[i][j] = 0; if (p[i] &lt;= n - j &amp;&amp; j &gt; 0 &amp;&amp; p[i] &gt;= i - 1) dp[i][j] = dp[i + 1][j - 1]; if (p[i] &lt;= j + i - 1 &amp;&amp; n - i - j + 1 &gt; 0 &amp;&amp; p[i] &gt;= i - 1) (dp[i][j] += dp[i + 1][j]) %= mod; if (i == 2) (ans += dp[i][j]) %= mod; &#125;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://yh2021shx.github.com/categories/Solutions/"}],"tags":[{"name":"Luogu","slug":"Luogu","permalink":"https://yh2021shx.github.com/tags/Luogu/"}]},{"title":"CSP-S 模拟赛 01 比赛报告","slug":"[23.07.17]CSPS01","date":"17/07/2023","updated":"11/11/2023","comments":true,"path":"2023/07/17/[23.07.17]CSPS01/","link":"","permalink":"https://yh2021shx.github.com/2023/07/17/[23.07.17]CSPS01/","excerpt":"","text":"1 概况 比赛情况： 场次 分数 排名 A B C D 23.07.17 155 #3 20\\color{yellow}{20}20 100\\color{green}{100}100 0\\color{red}{0}0 35\\color{yellow}{35}35 知识点 / 补题情况：（绿色为已补，红色为尝试补） A B C D 组合+性质\\color{green}{\\text{组合+性质}}组合+性质 拆点最短路\\color{green}{\\text{拆点最短路}}拆点最短路 图论\\color{red}{\\text{图论}}图论 博弈论+分讨\\color{red}{\\text{博弈论+分讨}}博弈论+分讨 2 比赛过程 先通读一遍，觉得 A 和 C 可做。先做 A，对着式子推很久没推出来 O(nlog⁡n)\\mathcal{O}(n\\log{n})O(nlogn)，决定先开 B。迭代了一下发现有周期，用拆点最短路快速写完看 C。一直不会 Subtask 2，决定先写暴力，样例过了。开 D，快速写完一个四维 dp，用暴力跑了几个 Subtask 4，找到规律了写上。本来以为这个能过 Subtask 3，但是因为 T≤50T \\leq 50T≤50 没过。写了 B 的对拍，很对，于是最后全力冲 A 失败了。 赛后发现 C 写挂了，调了一会暴力然后润了。 3 解题报告 Problem A. 情况 赛时 赛后 20\\color{yellow}{20}20 100\\color{green}{100}100 题目大意 对于所有 j(1≤j≤m)j(1 \\leq j \\leq m)j(1≤j≤m)，求出 ∑in(jai)\\sum_i^n\\binom{j}{a_i}∑in​(ai​j​)。 解法分析 通过 ∑inai≤105\\sum_i^na_i \\leq 10^5∑in​ai​≤105，我们得知不同 aia_iai​ 的取值个数 ≤105\\leq \\sqrt{10^5}≤105​。这个东西以前从来没有接触过。做不出来情有可原。 所以我们可以把相同的 aia_iai​ 拿到一起计算，直观时间复杂度为 O(n105log⁡n)\\mathcal{O}{(n\\sqrt{10^5}\\log{n})}O(n105​logn)，但可以证明为 O(n105)\\mathcal{O}(n\\sqrt{10^5})O(n105​)。 需要注意的是阶乘的逆元需要预处理，否则会被卡。 Problem B. 情况 赛时 赛后 100\\color{green}{100}100 100\\color{green}{100}100 题目大意 给定一个图，每走一步后图的每一条边的权值 www 会变成 1+x1−x mod p\\frac{1+x}{1-x}\\bmod p1−x1+x​modp，问从 111 到 nnn 的最短路。 解法分析 简单手玩一下这个式子，发现迭代两次后 w→−w mod pw \\rightarrow -w \\bmod pw→−wmodp。所以发现这个函数周期为 444，老套路拆点最短路即可。 Problem C. 情况 赛时 赛后 0\\color{red}{0}0 20\\color{yellow}{20}20 题目大意 给定一颗树和一个 kkk，会执行 kkk 次操作，每次操作会把原来的树复制到新树的叶子结点上，然后给定 qqq 次询问，求出 dfn 为 x,yx, yx,y 的两点的最短路。 解法分析 首先 k=0k = 0k=0 显然暴力 lca。 然后对于 k≤30k \\leq 30k≤30，容易想到把原树缩成点，我们就可以在 O(1)\\mathcal{O}(1)O(1) 的时间内计算出一棵树的根的子树大小。若每次要定位一个 dfn 为 xxx 的子树，可以从 111 开始往原树叶子结点跳，二分跳到哪个叶子结点即可。这样可以 O(klog⁡n)\\mathcal{O}(k\\log{n})O(klogn) 定位。最后我们可以通过类似倍增 lca 的方法，先让两个点深度相同再一起往上跳，跳到同一颗子树再来一遍普通 lca 即可。复杂度 O(k+log⁡n)\\mathcal{O}(k + \\log{n})O(k+logn)。 对于 k≤109k \\leq 10^9k≤109，容易发现大部分点都是没用的。排除冗余后只有左下角 30 层和根节点到左下角的一条链是有用的。预处理出这些结点然后套 k≤30k \\leq 30k≤30 即可。 Problem D. 情况 赛时 赛后 35\\color{yellow}{35}35 35\\color{yellow}{35}35 题目大意 给定 nnn 堆石子，两个人轮流取，每次可以取出开头和结尾的石子堆中若干个式子，谁不能取就输，问先手是否有必胜策略。 解法分析 题解没看懂 QAQ。 把我会的写出来吧。 首先可以定义 ll,rl_{l,r}ll,r​ 表示唯一的 xxx 使得 {x,al+1,⋯ ,ar}\\{x, a_{l+1}, \\cdots, a_r\\}{x,al+1​,⋯,ar​} 时先手必败，rl,rr_{l,r}rl,r​ 恰好相反。 先证明为何唯一。若存在 x&lt;yx &lt; yx&lt;y 满足先手必败，则当左边石子堆有 yyy 个时，先手可以取 y−xy - xy−x 个，则后手必败，矛盾。 然后就考虑 ll,rl_{l,r}ll,r​ 的递推，rl,rr_{l,r}rl,r​ 同理，不叙述。 设 x=arx = a_rx=ar​，则开始分讨： rl,r=xr_{l,r} = xrl,r​=x 显然 ll−1,r=0l_{l-1,r} = 0ll−1,r​=0。 x&lt;ll−1,r−1,x&lt;rl,rx &lt; l_{l - 1, r - 1}, x &lt; r_{l,r}x&lt;ll−1,r−1​,x&lt;rl,r​ 若 ll−1,r=xl_{l-1,r} = xll−1,r​=x，则后手可以走对称操作，这样一定会有先手操作完后，首尾有一堆石子被取完。又有 x&lt;ll−1,r−1,x&lt;rl,rx &lt; l_{l - 1,r - 1}, x &lt; r_{l, r}x&lt;ll−1,r−1​,x&lt;rl,r​，则后手必胜，先手必输。故 ll−1,r=xl_{l - 1, r} = xll−1,r​=x ll−1,r−1&gt;rl,r,rl,r&lt;x≤ll−1,r−1l_{l - 1, r - 1} &gt; r_{l, r}, r_{l,r} &lt; x \\leq l_{l - 1, r - 1}ll−1,r−1​&gt;rl,r​,rl,r​&lt;x≤ll−1,r−1​ 不会 TAT。 ll−1,r−1&lt;rl,r,ll−1,r−1≤x&lt;rl,rl_{l - 1, r - 1} &lt; r_{l, r}, l_{l - 1,r - 1} \\leq x &lt; r_{l, r}ll−1,r−1​&lt;rl,r​,ll−1,r−1​≤x&lt;rl,r​ 也不会 QwQ。 x&gt;ll−1,r−1,x&gt;rl,rx &gt; l_{l - 1, r - 1}, x &gt; r_{l, r}x&gt;ll−1,r−1​,x&gt;rl,r​ 没想 =。= 4 总结 时间复杂度没考虑清楚，导致 D 题挂分 误判 B 为神仙题，导致死磕 A 没及时检查，导致 C 挂大分","categories":[{"name":"Contest","slug":"Contest","permalink":"https://yh2021shx.github.com/categories/Contest/"}],"tags":[{"name":"CSP-S","slug":"CSP-S","permalink":"https://yh2021shx.github.com/tags/CSP-S/"}]},{"title":"ARC163 C 题题解","slug":"ARC163C","date":"03/07/2023","updated":"10/11/2023","comments":true,"path":"2023/07/03/ARC163C/","link":"","permalink":"https://yh2021shx.github.com/2023/07/03/ARC163C/","excerpt":"","text":"1 题目大意 1.1 题目翻译 给你一个 nnn，你需要构造一组大小为 nnn 的数组 {ai}\\{a_i\\}{ai​}，使得： ∑i=1n1ai=1\\sum_{i = 1}^n\\frac{1}{a_i} = 1∑i=1n​ai​1​=1 aaa 数组内的元素互不相同 1≤ai≤1091 \\leq a_i \\leq 10^91≤ai​≤109 有 ttt 组数据。 1.2 数据范围 对于 100%100\\%100% 的数据： 1≤n≤5001 \\leq n \\leq 5001≤n≤500 1≤t≤5001 \\leq t \\leq 5001≤t≤500 2 解法分析 0 前情提要 做这道题之前，你至少要想到 1n−1n+1=1n×(n+1)\\frac{1}{n}-\\frac{1}{n+1} = \\frac{1}{n \\times (n + 1)}n1​−n+11​=n×(n+1)1​，不然别搞 OI 了。自己骂自己是吧 1 题目解法 首先，n=1n = 1n=1 有 a={1}a = \\{1\\}a={1}，n=2n = 2n=2 无解。十分显然。接下来考虑 n&gt;3n &gt; 3n&gt;3 的情况。 由上面的式子得 1n×(n+1)+1n+1=1n\\frac{1}{n\\times(n + 1)} + \\frac{1}{n + 1} = \\frac{1}{n}n×(n+1)1​+n+11​=n1​，容易想到构造出 a={2,6,⋯ ,n×(n−1),n}a = \\{2, 6, \\cdots, n \\times (n - 1), n\\}a={2,6,⋯,n×(n−1),n}。此时，aaa 满足前两条要求。 但是第三条不一定。因为这个 nnn 可能是 k×(k+1)k \\times (k + 1)k×(k+1) 的形式，很烦。所以，考虑单独处理 n=k×(k+1)n = k \\times (k + 1)n=k×(k+1)。 接下来这一步很考验人的构造能力。既然 nnn 不好构造，我们就可以尝试把 nnn 变成 n−1n-1n−1。这时，可以设 a′={2,2×a1,2×a2,⋯ ,2×an−1}a&#x27; = \\{2, 2 \\times a_1, 2 \\times a_2, \\cdots, 2 \\times a_{n - 1}\\}a′={2,2×a1​,2×a2​,⋯,2×an−1​}。这时，我们把问题的规模缩小到了 n−1n - 1n−1，显然 n−1≠k×(k+1)n - 1 \\neq k \\times (k + 1)n−1=k×(k+1)。这个序列的证明也十分显然，这里不过多叙述。 至此，问题得解。 3 AC Code 123456789101112131415161718192021222324252627void solve() &#123; n = read(); if (n == 1) &#123; // 特判 1 printf(&quot;Yes\\n1\\n&quot;); return ; &#125; if (n == 2) &#123; // 特判 2 printf(&quot;No\\n&quot;); return ; &#125; /*判断 n 是否为形如 k * (k + 1) 的数*/ int k = 1; while (k * (k + 1) &lt; n) k ++; if (k * (k + 1) != n) &#123; // 不是，则 a = &#123;2, 6, ..., n * (n - 1), n&#125; printf(&quot;Yes\\n&quot;); f (i, 1, n - 1) printf(&quot;%lld &quot;, i * (i + 1)); printf(&quot;%lld\\n&quot;, n); &#125; else &#123; // 是，则 a = &#123;2, 4, 12, ..., 2 * (n - 2) * (n - 1), 2 * n - 2&#125; printf(&quot;Yes\\n2 &quot;); f (i, 1, n - 2) printf(&quot;%lld &quot;, 2 * i * (i + 1)); printf(&quot;%lld\\n&quot;, 2 * n - 2); &#125;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://yh2021shx.github.com/categories/Solutions/"}],"tags":[{"name":"ARC","slug":"ARC","permalink":"https://yh2021shx.github.com/tags/ARC/"}]},{"title":"ABC302 G 题题解","slug":"ABC302G","date":"29/06/2023","updated":"10/11/2023","comments":true,"path":"2023/06/29/ABC302G/","link":"","permalink":"https://yh2021shx.github.com/2023/06/29/ABC302G/","excerpt":"","text":"1 题目大意 1.1 题目翻译 有两个人轮流取物品。总共有 nnn 个物品，第 iii 个物品的价值为 wiw_iwi​。 他们按照下面的其中一种方式取物品： 取出这一排物品最前面的或者最后面的。这一步没有代价。 设还剩下 mmm 个物品，那么重复取出 min⁡(B,m)\\min(B, m)min(B,m) 个物品，每次取出最前面的或者最后面的。这一步的代价为 AAA。 设还剩下 mmm 个物品，那么重复取出 min⁡(D,m)\\min(D, m)min(D,m) 个物品，每次取出最前面的或者最后面的。这一步的代价为 CCC。 最后一个人取出物品的价值为所有他取出物品价值之和减去他所花费的代价。问当两人均以最优策略取物品时，先手取出物品的价值减去后手取出物品的价值为多少。 1.2 数据范围 对于 100%100\\%100% 的数据： 1≤B,D≤n≤30001 \\leq B, D \\leq n \\leq 30001≤B,D≤n≤3000 A,C≤109A, C \\leq 10 ^ 9A,C≤109 2 解法分析 2.1 初见此题 首先，一看这道题，我们就会发现：不管怎么取物品，任何时刻的序列一定是原序列的一段连续子区间。所以，我们不难想到区间 DP。 2.2 暴力 DP 设 fi,jf_{i, j}fi,j​ 表示当前序列为原序列从第 iii 个到第 jjj 个元素时，答案的最大值。那么，会有 333 种情况： 操作 1。此时，fi,j=max⁡(wi−fi+1,j,wj−fi,j−1)f_{i,j} = \\max(w_i - f_{i + 1, j}, w_j - f_{i, j - 1})fi,j​=max(wi​−fi+1,j​,wj​−fi,j−1​) 操作 2。设 l=j−i+1l = j - i + 1l=j−i+1，则： 当 B≥lB \\geq lB≥l 时： fi,j=(∑i≤k≤jwk)−Af_{i, j} = (\\sum_{i \\leq k \\leq j}w_k) - A fi,j​=(i≤k≤j∑​wk​)−A 当 B&lt;lB &lt; lB&lt;l 时： fi,j=max⁡0≤k≤B{(∑i≤p≤i+k−1wp)+(∑j−B+k+1≤p≤jwp)−A−fi+k,j−B+k}f_{i, j} = \\max_{0 \\leq k \\leq B}\\{(\\sum_{i \\leq p \\leq i + k - 1} w_p) + (\\sum_{j - B + k + 1 \\leq p \\leq j}w_p) - A - f_{i + k, j - B + k}\\} fi,j​=0≤k≤Bmax​{(i≤p≤i+k−1∑​wp​)+(j−B+k+1≤p≤j∑​wp​)−A−fi+k,j−B+k​} 操作 3。大致与操作 2 相同，这里就不过多叙述。 至此，我们完成了暴力 DP，时间复杂度为 O(n3)\\mathcal{O}(n^3)O(n3)，显然过不了。 所以，接下来，我们就要考虑优化。 暴力代码如下： 123456789101112131415161718192021222324252627int getsum(int l, int r)&#123; return sum[r] - sum[l - 1];&#125;void update(int A, int B, int i, int j, int &amp;x)&#123; if (B &gt;= j - i + 1) x = max(x, getsum(i, j) - A); else f (k, 0, B) x = max(x, getsum(i, j) - getsum(i + k, j - B + k) - A - dp[i + k][j - B + k]);&#125;signed main() &#123; cin &gt;&gt; n &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D; f (i, 1, n) &#123; scanf(&quot;%lld&quot;, &amp;w[i]); sum[i] = sum[i - 1] + w[i]; &#125; g (i, n, 1) f (j, i, n)&#123; dp[i][j] = max(w[i] - dp[i + 1][j], w[j] - dp[i][j - 1]); update(A, B, i, j, dp[i][j]); update(C, D, i, j, dp[i][j]); &#125; printf(&quot;%lld\\n&quot;, dp[1][n]); return 0;&#125; 2.3 DP 优化 观察 DP 方程。我们发现，极限复杂度只出现在了操作 2 当 B&lt;lB &lt; lB&lt;l 的情况。所以，我们把这个式子的 max⁡\\maxmax 去掉，得： (∑i≤p≤i+k−1wp)+(∑j−B+k+1≤p≤jwp)−A−fi+k,j−B+k(\\sum_{i \\leq p \\leq i + k - 1} w_p) + (\\sum_{j - B + k + 1 \\leq p \\leq j}w_p) - A - f_{i + k, j - B + k} (i≤p≤i+k−1∑​wp​)+(j−B+k+1≤p≤j∑​wp​)−A−fi+k,j−B+k​ 我们发现，(∑i≤p≤i+k−1wp)+(∑j−B+k+1≤p≤jwp)(\\sum_{i \\leq p \\leq i + k - 1} w_p) + (\\sum_{j - B + k + 1 \\leq p \\leq j}w_p)(∑i≤p≤i+k−1​wp​)+(∑j−B+k+1≤p≤j​wp​) 可以前缀和 O(1)\\mathcal{O}(1)O(1) 计算。设 sl,rs_{l, r}sl,r​ 为 lll 到 rrr 的物品价值之和，于是得： −si+k,j−B+k−fi+k,j−B+k−A+si,j-s_{i + k, j - B + k} - f_{i + k, j - B + k} - A + s_{i, j} −si+k,j−B+k​−fi+k,j−B+k​−A+si,j​ 观察这个方程。我们把 kkk 视为未知数，i,ji, ji,j 视为常数，则 si,j−As_{i,j} - Asi,j​−A 为常数，可以提到 max⁡\\maxmax 外面。所以，我们需要维护的只有： si+k,j−B+k+fi+k,j−B+ks_{i + k, j - B + k} + f_{i + k, j - B + k} si+k,j−B+k​+fi+k,j−B+k​ 发现这两个区间的长度都是 (j−B+k)−(i+k)=j−i−B+1(j - B + k) - (i + k) = j - i - B + 1(j−B+k)−(i+k)=j−i−B+1，那么相当于只需要维护长度为 xxx 的 fi,i+x−1+si,i+x−1f_{i, i + x - 1} + s_{i, i + x - 1}fi,i+x−1​+si,i+x−1​ 中最小的一个即可。 这有许多维护方法，比如优先队列，线段树，ST 表。 至此，这道题就完成了。时间复杂度为 O(n2)\\mathcal{O}(n^2)O(n2) 或者 O(n2log⁡n)\\mathcal{O}(n^2\\log{n})O(n2logn) 这里我使用了 ST 表，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354int getsum(int l, int r)&#123; return sum[r] - sum[l - 1];&#125;void init()&#123; f (i, 2, n) lg[i] = lg[i / 2] + 1;&#125;int query(int l, int r)&#123; int p = lg[r - l + 1]; return min(st[l][p], st[r - (1ll &lt;&lt; p) + 1][p]);&#125;void update(int A, int B, int i, int j, int &amp;x)&#123; if (B &gt;= j - i + 1) x = max(x, getsum(i, j) - A); else x = max(x, getsum(i, j) - A - query(i, i + B));&#125;void build(int len)&#123; f (i, 1, n - len + 1) st[i][0] = dp[i][i + len - 1] + getsum(i, i + len - 1); f (j, 1, 15) f (i, 1, n - len + 2 - (1ll &lt;&lt; j)) st[i][j] = min(st[i][j - 1], st[i + (1ll &lt;&lt; (j - 1))][j - 1]);&#125;signed main() &#123; cin &gt;&gt; n &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D; f (i, 1, n) &#123; scanf(&quot;%lld&quot;, &amp;w[i]); sum[i] = sum[i - 1] + w[i]; &#125; init(); f (len, 1, n) &#123; f (i, 1, n - len + 1)&#123; int j = i + len - 1; dp[i][j] = max(w[i] - dp[i + 1][j], w[j] - dp[i][j - 1]); &#125; if (len &gt; B) build(len - B); f (i, 1, n - len + 1) update(A, B, i, i + len - 1, dp[i][i + len - 1]); if (len &gt; D) build(len - D); f (i, 1, n - len + 1) &#123; update(C, D, i, i + len - 1, dp[i][i + len - 1]); &#125; &#125; printf(&quot;%lld\\n&quot;, dp[1][n]); return 0;&#125;","categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://yh2021shx.github.com/categories/Solutions/"}],"tags":[{"name":"ABC","slug":"ABC","permalink":"https://yh2021shx.github.com/tags/ABC/"}]}],"categories":[{"name":"Solutions","slug":"Solutions","permalink":"https://yh2021shx.github.com/categories/Solutions/"},{"name":"School","slug":"Solutions/School","permalink":"https://yh2021shx.github.com/categories/Solutions/School/"},{"name":"Codeforces","slug":"Solutions/Codeforces","permalink":"https://yh2021shx.github.com/categories/Solutions/Codeforces/"},{"name":"Luogu","slug":"Solutions/Luogu","permalink":"https://yh2021shx.github.com/categories/Solutions/Luogu/"},{"name":"CSP-S","slug":"CSP-S","permalink":"https://yh2021shx.github.com/categories/CSP-S/"},{"name":"CSP-S","slug":"Solutions/CSP-S","permalink":"https://yh2021shx.github.com/categories/Solutions/CSP-S/"},{"name":"Atcoder","slug":"Solutions/Atcoder","permalink":"https://yh2021shx.github.com/categories/Solutions/Atcoder/"},{"name":"Notebook","slug":"Notebook","permalink":"https://yh2021shx.github.com/categories/Notebook/"},{"name":"Contest","slug":"Contest","permalink":"https://yh2021shx.github.com/categories/Contest/"}],"tags":[{"name":"School","slug":"School","permalink":"https://yh2021shx.github.com/tags/School/"},{"name":"线段树","slug":"线段树","permalink":"https://yh2021shx.github.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"图论","slug":"图论","permalink":"https://yh2021shx.github.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"循环节","slug":"循环节","permalink":"https://yh2021shx.github.com/tags/%E5%BE%AA%E7%8E%AF%E8%8A%82/"},{"name":"Div-2","slug":"Div-2","permalink":"https://yh2021shx.github.com/tags/Div-2/"},{"name":"构造","slug":"构造","permalink":"https://yh2021shx.github.com/tags/%E6%9E%84%E9%80%A0/"},{"name":"二进制","slug":"二进制","permalink":"https://yh2021shx.github.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"Luogu","slug":"Luogu","permalink":"https://yh2021shx.github.com/tags/Luogu/"},{"name":"CSP-S","slug":"CSP-S","permalink":"https://yh2021shx.github.com/tags/CSP-S/"},{"name":"游记","slug":"游记","permalink":"https://yh2021shx.github.com/tags/%E6%B8%B8%E8%AE%B0/"},{"name":"2023","slug":"2023","permalink":"https://yh2021shx.github.com/tags/2023/"},{"name":"ABC","slug":"ABC","permalink":"https://yh2021shx.github.com/tags/ABC/"},{"name":"折半搜索","slug":"折半搜索","permalink":"https://yh2021shx.github.com/tags/%E6%8A%98%E5%8D%8A%E6%90%9C%E7%B4%A2/"},{"name":"Note","slug":"Note","permalink":"https://yh2021shx.github.com/tags/Note/"},{"name":"ARC","slug":"ARC","permalink":"https://yh2021shx.github.com/tags/ARC/"}]}